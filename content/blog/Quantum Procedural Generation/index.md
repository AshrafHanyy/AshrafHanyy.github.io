---
title: 'Quantum Random Walk for Procedural Generation'
date: 2024-09-25
summary: 'Researching QPG for random terrain generation with Dr. Ahmed Farouk'
authors:
  - admin
tags: 
# Display this page in the Featured widget?
featured: true
---
In this blog post, we'll explore how quantum computing principles can be applied to procedural generation, specifically for generating random terrain. Procedural generation is essential in fields such as gaming, where vast landscapes and terrains need to be created with minimal human intervention. Here, we'll use a quantum walk algorithm to generate random movements on a 2D grid, simulating terrain generation.

## What is Quantum Procedural Generation (QPG)?

Quantum Procedural Generation leverages quantum mechanics to introduce randomness and superposition in procedural algorithms. Classical algorithms use pseudo-random number generators, but quantum computing offers a more intrinsic form of randomness through quantum states. This allows for innovative approaches in generating unpredictable terrain, patterns, or even paths within games.

In this example, we use a **quantum walk** to generate a random sequence of moves on a 2D grid.

---

## Code Overview

We start by importing the necessary libraries. The code uses PennyLane, a quantum computing framework, along with NumPy and Matplotlib to handle the quantum operations and visualize the results.

```python
import pennylane as qml
from pennylane import numpy as np
import matplotlib.pyplot as plt
from IPython.display import display, clear_output
```

We are using **2 qubits** to represent movement in two directions (X and Y) on a 2D grid. Each qubit will influence a specific movement direction based on the quantum states they take.

```python
n_qubits = 2
dev = qml.device('default.qubit', wires=n_qubits, shots=2024)
```

## Creating the Quantum Walk Function

The `quantum_walk` function defines how qubits will evolve to create random movements. We apply a **Hadamard gate** to each qubit, which puts them into a state of superposition—essentially allowing us to sample from a range of possibilities.

```python
@qml.qnode(dev)
def quantum_walk():
    # Apply Hadamard gates to create superposition (randomness in movement)
    qml.Hadamard(wires=0)  # X-direction movement
    qml.Hadamard(wires=1)  # Y-direction movement
    return qml.sample(wires=[0, 1])
```

## Setting Up the 2D Grid

We initialize a grid of size 10x10 and define the number of steps the quantum walker will take. Each step corresponds to a movement either up, down, left, or right. A dictionary is used to translate the quantum results into directional movements.

```python
grid_size = 10
steps = 200

grid = np.zeros((grid_size, grid_size), dtype='int')
x, y = 0, 0

directions = {
    (0, 0): (0, 1),   # Move up
    (0, 1): (1, 0),   # Move right
    (1, 0): (0, -1),  # Move down
    (1, 1): (-1, 0)   # Move left
}
```

## Running the Quantum Walk and Visualizing the Results

The loop below runs the quantum walk for a specified number of steps, updating the position on the grid based on the quantum result. Every few steps, the plot is updated to display the walker’s path on the grid. The movement is wrapped around the grid, ensuring that the walker doesn't leave the boundary.

```python
for step in range(steps):
    results = quantum_walk()  # Quantum walk result
    random_step = np.random.randint(len(results))  # Randomly select a step
    result = results[random_step]
    result_tuple = tuple(int(val) for val in result)  # Convert to tuple

    # Update the position based on movement direction
    dx, dy = directions[result_tuple]
    x, y = (x + dx) % grid_size, (y + dy) % grid_size
    grid[x, y] = 1

    if step % 1 == 0:
        ax.clear()
        ax.imshow(grid, cmap='Greys', interpolation='nearest')
        ax.set_xlabel('X-axis')
        ax.set_ylabel('Y-axis')
        ax.set_title(f"Quantum Procedural Generation using PennyLane ({step + 1} steps)")
        display(fig)
        clear_output(wait=True)
        plt.pause(0.1)
```

At the end of the loop, we display the final path generated by the quantum walk.

```python
plt.show()
```

## Key Takeaways

- **Quantum randomness:** Instead of relying on classical random number generators, we leverage the inherent randomness of quantum mechanics, which introduces more unpredictability into the terrain generation process.
- **Superposition:** Using Hadamard gates allows the walker to simultaneously explore multiple possible directions, enhancing the random nature of the movement.
- **Visualization:** The visual output shows how the walker’s random steps can create unpredictable terrain patterns on the grid.

---

This code serves as a basic implementation of Quantum Procedural Generation, where quantum computing principles are applied to randomly generate movements on a 2D grid. The resulting patterns could be used for generating terrain in games or simulating random exploration processes.

As quantum computing advances, more complex forms of procedural generation will become possible, offering new and exciting possibilities in game design and beyond. Stay tuned as we continue our research with Dr. Ahmed Farouk to explore the broader applications of QPG!

---

**Next Steps:** Future implementations could extend this quantum walk to 3D grids or even incorporate quantum circuits with more complex gates to introduce richer variability in terrain generation.
